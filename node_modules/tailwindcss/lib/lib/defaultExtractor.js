"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "defaultExtractor", {
    enumerable: true,
    get: function() {
        return defaultExtractor;
    }
});
const _regex = /*#__PURE__*/ _interop_require_wildcard(require("./regex"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function defaultExtractor(context) {
    let patterns = Array.from(buildRegExps(context));
    /**
   * @param {string} content
   */ return (content)=>{
        /** @type {(string|string)[]} */ let results = [];
        for (let pattern of patterns){
            var _content_match;
            for (let result of (_content_match = content.match(pattern)) !== null && _content_match !== void 0 ? _content_match : []){
                results.push(clipAtBalancedParens(result));
            }
        }
        return results;
    };
}
function* buildRegExps(context) {
    let separator = context.tailwindConfig.separator;
    let prefix = context.tailwindConfig.prefix !== "" ? _regex.optional(_regex.pattern([
        /-?/,
        _regex.escape(context.tailwindConfig.prefix)
    ])) : "";
    let utility = _regex.any([
        // Arbitrary properties (without square brackets)
        /\[[^\s:'"`]+:[^\s\[\]]+\]/,
        // Arbitrary properties with balanced square brackets
        // This is a targeted fix to continue to allow theme()
        // with square brackets to work in arbitrary properties
        // while fixing a problem with the regex matching too much
        /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
        // Utilities
        _regex.pattern([
            // Utility Name / Group Name
            _regex.any([
                /-?(?:\w+)/,
                // This is here to make sure @container supports everything that other utilities do
                /@(?:\w+)/
            ]),
            // Normal/Arbitrary values
            _regex.optional(_regex.any([
                _regex.pattern([
                    // Arbitrary values
                    _regex.any([
                        /-(?:\w+-)*\['[^\s]+'\]/,
                        /-(?:\w+-)*\["[^\s]+"\]/,
                        /-(?:\w+-)*\[`[^\s]+`\]/,
                        /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/
                    ]),
                    // Not immediately followed by an `{[(`
                    /(?![{([]])/,
                    // optionally followed by an opacity modifier
                    /(?:\/[^\s'"`\\><$]*)?/
                ]),
                _regex.pattern([
                    // Arbitrary values
                    _regex.any([
                        /-(?:\w+-)*\['[^\s]+'\]/,
                        /-(?:\w+-)*\["[^\s]+"\]/,
                        /-(?:\w+-)*\[`[^\s]+`\]/,
                        /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/
                    ]),
                    // Not immediately followed by an `{[(`
                    /(?![{([]])/,
                    // optionally followed by an opacity modifier
                    /(?:\/[^\s'"`\\$]*)?/
                ]),
                // Normal values w/o quotes ‚Äî may include an opacity modifier
                /[-\/][^\s'"`\\$={><]*/
            ]))
        ])
    ]);
    let variantPatterns = [
        // Without quotes
        _regex.any([
            // This is here to provide special support for the `@` variant
            _regex.pattern([
                /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
                separator
            ]),
            // With variant modifier (e.g.: group-[..]/modifier)
            _regex.pattern([
                /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/[\w_-]+/,
                separator
            ]),
            _regex.pattern([
                /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
                separator
            ]),
            _regex.pattern([
                /[^\s"'`\[\\]+/,
                separator
            ])
        ]),
        // With quotes allowed
        _regex.any([
            // With variant modifier (e.g.: group-[..]/modifier)
            _regex.pattern([
                /([^\s"'`\[\\]+-)?\[[^\s`]+\]\/[\w_-]+/,
                separator
            ]),
            _regex.pattern([
                /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
                separator
            ]),
            _regex.pattern([
                /[^\s`\[\\]+/,
                separator
            ])
        ])
    ];
    for (const variantPattern of variantPatterns){
        yield _regex.pattern([
            // Variants
            "((?=((",
            variantPattern,
            ")+))\\2)?",
            // Important (optional)
            /!?/,
            prefix,
            utility
        ]);
    }
    // 5. Inner matches
    yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
// We want to capture any "special" characters
// AND the characters immediately following them (if there is one)
let SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
let ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
/**
 * Clips a string ensuring that parentheses, quotes, etc‚Ä¶ are balanced
 * Used for arbitrary values only
 *
 * We will go past the end of the balanced parens until we find a non-class character
 *
 * Depth matching behavior:
 * w-[calc(100%-theme('spacing[some_key][1.5]'))]']
 *   ‚î¨    ‚î¨          ‚î¨‚î¨       ‚î¨        ‚î¨‚î¨   ‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨
 *   1    2          3        4        34   3 210 END
 *   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚î¥‚î¥‚î¥
 *
 * @param {string} input
 */ function clipAtBalancedParens(input) {
    // We are care about this for arbitrary values
    if (!input.includes("-[")) {
        return input;
    }
    let depth = 0;
    let openStringTypes = [];
    // Find all parens, brackets, quotes, etc
    // Stop when we end at a balanced pair
    // This is naive and will treat mismatched parens as balanced
    // This shouldn't be a problem in practice though
    let matches = input.matchAll(SPECIALS);
    // We can't use lookbehind assertions because we have to support Safari
    // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate
    matches = Array.from(matches).flatMap((match)=>{
        const [, ...groups] = match;
        return groups.map((group, idx)=>Object.assign([], match, {
                index: match.index + idx,
                0: group
            }));
    });
    for (let match of matches){
        let char = match[0];
        let inStringType = openStringTypes[openStringTypes.length - 1];
        if (char === inStringType) {
            openStringTypes.pop();
        } else if (char === "'" || char === '"' || char === "`") {
            openStringTypes.push(char);
        }
        if (inStringType) {
            continue;
        } else if µ –≤—ã–±—Ä–∞–Ω–°–±—Ä–æ—Å –¥–Ω—è –∏–∑-–∑–∞ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–π –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è–°–±—Ä–æ—Å –º–µ—Å—è—Ü–∞ –∏–∑-–∑–∞ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–π –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è–ü–æ–∫–∞–∑–∞—Ç—å –±–æ–ª—å—à–µ–ú–µ–Ω—å—à–µ–°—Ä–µ–¥–Ω—è—è —á–∞—Å—Ç—å –∏–º–µ–Ω–∏, –æ—Ç—á–µ—Å—Ç–≤–æ–§–∞–º–∏–ª–∏—è–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ —É—á–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏ –ú–∞–π–∫—Ä–æ—Å–æ—Ñ—Ç–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤ —É—á–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏ –ú–∞–π–∫—Ä–æ—Å–æ—Ñ—Ç–£–¥–∞–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã–≠—Ç–∞ –∫–∞—Ä—Ç–∞ –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–∞ —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞, –Ω–æ –≤—ã —Å–º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–µ —Å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π –ø–æ–¥–ª–∏–Ω–Ω–æ—Å—Ç–∏, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∑–¥–µ—Å—å:–£—á–µ—Ç–Ω–∞—è –∑–∞–ø–∏—Å—å –ú–∞–π–∫—Ä–æ—Å–æ—Ñ—Ç–£—á–µ—Ç–Ω–∞—è –∑–∞–ø–∏—Å—å –ú–∞–π–∫—Ä–æ—Å–æ—Ñ—Ç.–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞—Ä—Ç—É –≤ —É—á–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏ –ú–∞–π–∫—Ä–æ—Å–æ—Ñ—Ç?(–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)–†–µ–∫–≤–∏–∑–∏—Ç—ã –∫–∞—Ä—Ç—ã–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ —É—á–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏ –ú–∞–π–∫—Ä–æ—Å–æ—Ñ—Ç–°–≤–µ–¥–µ–Ω–∏—è –æ –≤–∑–Ω–æ—Å–µ–í–∑–Ω–æ—Å—ã–ü—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–∞—à–∏ –≤–∑–Ω–æ—Å—ã –ø–æ –ø—Ä–æ–≥—Ä–∞–º–º–µ "–ö—É–ø–∏—Ç–µ —Å–µ–π—á–∞—Å, –æ–ø–ª–∞—Ç–∏—Ç–µ –ø–æ–∑–∂–µ"–ü—Å–µ–≤–¥–æ–Ω–∏–º–î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞–£–¥–∞–ª–µ–Ω–æ: $1–ö—Ä–µ