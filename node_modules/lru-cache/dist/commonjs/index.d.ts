ø–∞–π–¥–∞–ª–∞–Ω–∞—Ç—ã–Ω –∫–µ–∑ –∫–µ–ª–≥–µ–Ω –ø–∞–π–¥–∞–ª–∞–Ω—É—à—ã –∂“Ø–∫—Ç–µ–ø –∞–ª—ã–Ω“ì–∞–Ω —Ñ–∞–π–ª–¥–∞—Ä–¥—ã –∫”©—Ä–µ –∞–ª–∞–¥—ã$1 –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É$1 –∫—ñ–¥—ñ—Ä—Ç—É$1 –±–∞—Å —Ç–∞—Ä—Ç—É$1 —Ñ–∞–π–ª—ã–Ω –∞—à—É“ö–∞–ª—Ç–∞–¥–∞“ì—ã $1 —Ñ–∞–π–ª—ã–Ω –∫”©—Ä—Å–µ—Ç—É¬´–°–æ“£“ì—ã –∂“Ø–∫—Ç–µ—É–ª–µ—Ä¬ª —Ç–∞—Ä–º–∞“ì—ã–Ω–∞ –æ—Ä–∞–ª—É$1 —Ñ–∞–π–ª—ã–Ω –∂–æ—é$1 —Ñ–∞–π–ª—ã–Ω —Å–∞“õ—Ç–∞—É$1 —Ñ–∞–π–ª—ã–Ω —Å–∫–∞–Ω–µ—Ä–ª–µ—É$1 —Ñ–∞–π–ª—ã–Ω “õ–∞–∑—ñ—Ä –∞—à—É$1 —Ñ–∞–π–ª—ã–Ω “õ–∞—Ä–∞–ø —à—ã“ì—É$1 —Ñ–∞–π–ª—ã–Ω “õ–∞–π—Ç–∞–ª–∞—É$1 —Ñ–∞–π–ª—ã–Ω —Å–æ–Ω–¥–∞ –¥–∞ –∞—à—É–ñ“Ø–∫—Ç–µ–ø –∞–ª—É–ª–∞—Ä –∞—è“õ—Ç–∞–ª“ì–∞–Ω–¥–∞ –∫”©—Ä—Å–µ—Ç–ø–µ—É–ú“±–Ω—ã –∫–µ–∑ –∫–µ–ª–≥–µ–Ω —É–∞“õ—ã—Ç—Ç–∞ $1 –±”©–ª—ñ–º—ñ–Ω–µ–Ω ”©–∑–≥–µ—Ä—Ç—É–≥–µ –±–æ–ª–∞–¥—ã{COUNT, plural, =1 {1 –∂“Ø–∫—Ç–µ–º–µ –æ—Ä—ã–Ω–¥–∞–ª—É–¥–∞} one {# –∂“Ø–∫—Ç–µ–º–µ –æ—Ä—ã–Ω–¥–∞–ª—É–¥–∞} other {# –∂“Ø–∫—Ç–µ–º–µ –æ—Ä—ã–Ω–¥–∞–ª—É–¥–∞}}–ë“±–ª —Ñ–∞–π–ª –∂–µ–∫–µ —Ç—ñ—Ä–∫–µ–ª–≥—ñ–ª–µ—Ä—ñ“£—ñ–∑–≥–µ –∂”ô–Ω–µ ”ô–ª–µ—É–º–µ—Ç—Ç—ñ–∫ –∂–µ–ª—ñ–ª–µ—Ä–¥–µ–≥—ñ —Ç—ñ—Ä–∫–µ–ª–≥—ñ–ª–µ—Ä—ñ“£—ñ–∑–≥–µ –∑–∏—è–Ω –∫–µ–ª—Ç—ñ—Ä—É—ñ –º“Ø–º–∫—ñ–Ω–ë“±–ª —Ñ–∞–π–ª –∂–µ–∫–µ —Ç—ñ—Ä–∫–µ–ª–≥—ñ–ª–µ—Ä—ñ“£—ñ–∑–≥–µ –Ω–µ–º–µ—Å–µ ”ô–ª–µ—É–º–µ—Ç—Ç—ñ–∫ –∂–µ–ª—ñ–ª–µ—Ä–¥–µ–≥—ñ —Ç—ñ—Ä–∫–µ–ª–≥—ñ–ª–µ—Ä—ñ“£—ñ–∑–≥–µ, —Å–æ–Ω—ã“£ —ñ—à—ñ–Ω–¥–µ $1 —Ç—ñ—Ä–∫–µ–ª–≥—ñ“£—ñ–∑–≥–µ –∑–∏—è–Ω —Ç–∏–≥—ñ–∑—É—ñ –º“Ø–º–∫—ñ–Ω–ë“±–ª —Ñ–∞–π–ª –∑–∏—è–Ω–¥—ã –±–∞“ì–¥–∞—Ä–ª–∞–º–∞–Ω—ã –∂–∞—Å—ã—Ä—É—ã –º“Ø–º–∫—ñ–Ω–ê—à—É –∞–ª–¥—ã–Ω–¥–∞ —Ç–µ–∫—Å–µ—Ä—É–°–∫–∞–Ω–µ—Ä–ª–µ–Ω—É–¥–µ‚Ä¶–ë“±–ª —Ñ–∞–π–ª –≤–∏—Ä—É—Å –Ω–µ–º–µ—Å–µ –∑–∏—è–Ω–¥—ã –±–∞“ì–¥–∞—Ä–ª–∞–º–∞ –±–æ–ª—É—ã –º“Ø–º–∫—ñ–Ω.

“ö–∞—É—ñ–ø—Å—ñ–∑–¥—ñ–≥—ñ–Ω —Ç–µ–∫—Å–µ—Ä—É “Ø—à—ñ–Ω –æ–Ω—ã Microsoft  –∫–æ—Ä–ø–æ—Ä–∞—Ü–∏—è—Å—ã–Ω–∞ –∂—ñ–±–µ—Ä—É–≥–µ –±–æ–ª–∞–¥—ã. –°–∫–∞–Ω–µ—Ä–ª–µ—É ”ô–¥–µ—Ç—Ç–µ –±—ñ—Ä–Ω–µ—à–µ —Å–µ–∫—É–Ω–¥—Ç—ã –∞–ª–∞–¥—ã.–ë“±–ª —à–∏—Ñ—Ä–ª–∞–Ω“ì–∞–Ω —Ñ–∞–π–ª –≤–∏—Ä—É—Å –Ω–µ–º–µ—Å–µ –∑–∏—è–Ω–¥—ã –±–∞“ì–¥–∞—Ä–ª–∞–º–∞–ª–∞—Ä –±–æ–ª—É—ã –º“Ø–º–∫—ñ–Ω.$1–û–Ω—ã“£ “õ–∞—É—ñ–ø—Å—ñ–∑ –µ–∫–µ–Ω—ñ–Ω —Ç–µ–∫—Å–µ—Ä—É “Ø—à—ñ–Ω, —Ñ–∞–π–ª –º–µ–Ω “õ“±–ø–∏—è—Å”©–∑–¥—ñ Google “õ–∞—É—ñ–ø—Å—ñ–∑ —à–æ–ª—É “õ—ã–∑–º–µ—Ç—ñ–Ω–µ –∂—ñ–±–µ—Ä—É–≥–µ –±–æ–ª–∞–¥—ã. –°–∫–∞–Ω–µ—Ä–ª–µ—É ”ô–¥–µ—Ç—Ç–µ –±—ñ—Ä–Ω–µ—à–µ —Å–µ–∫—É–Ω–¥—Ç—ã –∞–ª–∞–¥—ã.$1–°–∫–∞–Ω–µ—Ä–ª–µ—É “Ø—à—ñ–Ω —Ñ–∞–π–ª–¥—ã“£ “õ“±–ø–∏—è —Å”©–∑—ñ–Ω “õ–æ—Å—ã“£—ã–∑.Microsoft “õ–∞—É—ñ–ø—Å—ñ–∑ —à–æ–ª—É–§–∞–π–ª–¥—ã“£ “õ“±–ø–∏—è—Å”©–∑—ñ–§–∞–π–ª–¥—ã“£ “õ“±–ø–∏—è—Å”©–∑—ñ–Ω –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑“ö–∞—Ç–µ “õ“±–ø–∏—è—Å”©–∑. “ö–∞–π—Ç–∞–ª–∞–ø –∫”©—Ä—ñ“£—ñ–∑.–ë–∞“ì–¥–∞—Ä–ª–∞–º–∞ “õ–æ–ª–∂–µ—Ç—ñ–º–¥—ñ. $1 –±–∞“ì–¥–∞—Ä–ª–∞–º–∞—Å—ã–Ω –æ—Ä–Ω–∞—Ç—É–ë–∞“ì–¥–∞—Ä–ª–∞–º–∞–Ω—ã –æ—Ä–Ω–∞—Ç—É–û—Ä–Ω–∞—Ç—É–¢–∞“£–±–∞—à–∞–Ω—ã“£ –∞—Ç–∞—É—ã“ö–æ–π—ã–Ω—à–∞–ª—ã —Ç–µ—Ä–µ–∑–µ —Ä–µ—Ç—ñ–Ω–¥–µ –∞—à—É–ê—Ç–∞—É –∂–∞“£–∞—Ä—Ç—É—ã–Ω “õ–∞—Ä–∞–ø —à—ã“ì—É–ë–µ–ª–≥—ñ—à–µ–Ω—ñ“£ –∂–∞“£–∞—Ä—Ç—É—ã–Ω —Ç–µ–∫—Å–µ—Ä—É–ê—Ç–∞—É –º–µ–Ω –±–µ–ª–≥—ñ—à–µ –∂–∞“£–∞—Ä—Ç—É–ª–∞—Ä—ã–Ω “õ–∞—Ä–∞–ø —à—ã“ì—É–ï–≥–µ—Ä –±“±–ª –≤–µ–±-–±–∞“ì–¥–∞—Ä–ª–∞–º–∞ ”©–∑—ñ–Ω –±–∞—Å“õ–∞ –±–∞“ì–¥–∞—Ä–ª–∞–º–∞ —Ä–µ—Ç—ñ–Ω–¥–µ –∫”©—Ä—Å–µ—Ç—É–≥–µ —Ç—ã—Ä—ã—Å—Å–∞, –æ–Ω—ã –∂–æ–π—ã“£—ã–∑.–ê“ì—ã–º–¥–∞“ì—ã –±–µ–ª–≥—ñ—à–µ–ñ–∞“£–∞ –±–µ–ª–≥—ñ—à–µ–ë–∞“ì–¥–∞—Ä–ª–∞–º–∞–Ω—ã –∂–æ—é–¢–∞–ø—Å—ã—Ä–º–∞–ª–∞—Ä —Ç–∞“õ—Ç–∞—Å—ã–Ω–∞ &–±–µ–∫—ñ—Ç—É–û—Ä–Ω–∞—Ç—É $1Store —ñ—à—ñ–Ω–µ–Ω “õ–∞—Ä–∞–ø —à—ã“ì—É”ò–∑—ñ—Ä–ª–µ—É—à—ñ –≤–µ–±-—Å–∞–π—Ç—ã–õ–∏—Ü–µ–Ω–∑–∏—è–ª–∞—Ä—ã”®–ª—à–µ–º—ñ:–ù“±—Å“õ–∞:–¢–∞“£–±–∞—à–∞–Ω—ã –∂–∞—Å–∞—É‚Ä¶–ë“±–ª –±–∞“ì–¥–∞—Ä–ª–∞–º–∞–Ω—ã“£ “õ–∞–ª–∞–π —ñ—Å–∫–µ “õ–æ—Å—ã–ª—É—ã–Ω “õ–∞–ª–∞—Ä –µ–¥—ñ“£—ñ–∑?–ï—Å–µ–ø—Ç–µ—É–¥–µ‚Ä¶< 1 –ú–±–∞–π—Ç"$1" —Ä“±“õ—Å–∞—Ç—ã–Ω—ã“£ –∫“Ø—à—ñ–Ω –∂–æ—é–ë“±–ª –±–∞“ì–¥–∞—Ä–ª–∞–º–∞ –∞—Ä–Ω–∞–π—ã —Ä“±“õ—Å–∞—Ç—Ç–∞—Ä–¥—ã “õ–∞–∂–µ—Ç –µ—Ç–ø–µ–π–¥—ñ.–ë“±–ª –∫–µ“£–µ–π—Ç—ñ–º –∞—Ä–Ω–∞–π—ã —Ä“±“õ—Å–∞—Ç—Ç–∞—Ä–¥—ã —Ç–∞–ª–∞–ø –µ—Ç–ø–µ–π–¥—ñ.{NUM_FILES, plural,
           =1 {–ö–æ–º–ø—å—é—Ç–µ—Ä–¥–µ —Å–∞“õ—Ç–∞–ª“ì–∞–Ω —Ñ–∞–π–ª“ì–∞ –∫—ñ—Ä—É}
           one {–ö–æ–º–ø—å—é—Ç–µ—Ä–¥–µ —Å–∞“õ—Ç–∞–ª“ì–∞–Ω # —Ñ–∞–π–ª“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É}
           other {–ö–æ–º–ø—å—é—Ç–µ—Ä–¥–µ —Å–∞“õ—Ç–∞–ª“ì–∞–Ω # —Ñ–∞–π–ª“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É}}{NUM_DEVICES, plural,
         =1 {USB “õ“±—Ä—ã–ª“ì—ã—Å—ã–º–µ–Ω –±–∞–π–ª–∞–Ω—ã—Å—É}
         one {# USB “õ“±—Ä—ã–ª“ì—ã—Å—ã–º–µ–Ω –±–∞–π–ª–∞–Ω—ã—Å—É}
         other {# USB “õ“±—Ä—ã–ª“ì—ã—Å—ã–º–µ–Ω –±–∞–π–ª–∞–Ω—ã—Å—É}}–ö–µ–ª–µ—Å—ñ “Ø—à—ñ–Ω –±–∞“ì–¥–∞—Ä–ª–∞–º–∞–Ω—ã –±–µ–∫—ñ—Ç—É–ñ“±–º—ã—Å “Ø—Å—Ç–µ–ª—ñ–ë–µ–∫—ñ—Ç—É–ë–∞—Å—Ç–∞—É –º”ô–∑—ñ—Ä—ñ“ö“±—Ä—ã–ª“ì—ã–Ω—ã“£ –∫—ñ—Ä—É –∞“õ–ø–∞—Ä–∞—Ç—Ç–∞—Ä—ã$1 “õ“±—Ä—ã–ª“ì—ã—Å—ã–Ω–∞ –∞—Ä–Ω–∞–ª“ì–∞–Ω Bluetooth –∫—ñ—Ä—É –∫—ñ–ª—Ç—ñ–Ω –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑–ñ“±–ø—Ç–∞—Å—Ç—ã—Ä—É–¥—ã —Ä–∞—Å—Ç–∞—É$1 Bluetooth “õ“±—Ä—ã–ª“ì—ã—Å—ã –∂“±–ø—Ç–∞—Å—Ç—ã—Ä—É“ì–∞ —Ä“±“õ—Å–∞—Ç –∞–ª—É“ì–∞ ”ô—Ä–µ–∫–µ—Ç—Ç–µ–Ω—É–¥–µ.–ö—ñ—Ä—É –∫—ñ–ª—Ç—ñ–Ω —Ä–∞—Å—Ç–∞—É$1 $2 Bluetooth “õ“±—Ä—ã–ª“ì—ã—Å—ã–Ω–¥–∞ –∫”©—Ä—Å–µ—Ç—ñ–ª–µ—Ç—ñ–Ω –∫—ñ—Ä—É –∫—ñ–ª—Ç—ñ –µ–∫–µ–Ω—ñ–Ω —Ä–∞—Å—Ç–∞“£—ã–∑.–ë—ñ—Ä–Ω–µ—à–µ —Ñ–∞–π–ª–¥–∞—Ä–¥—ã –∞–≤—Ç–æ–º–∞—Ç—Ç—ã —Ç“Ø—Ä–¥–µ –∂“Ø–∫—Ç–µ–ø –∞–ª—É ”ô—Ä–µ–∫–µ—Ç—ñ–Ω –±–ª–æ–∫—Ç–∞—É–¥—ã –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–∞ –±—ñ—Ä–Ω–µ—à–µ —Ñ–∞–π–ª–¥—ã –∂“Ø–∫—Ç–µ–ø –∞–ª—É“ì–∞ —Ä“±“õ—Å–∞—Ç –µ—Ç—É–û—Å—ã —Å–∞–π—Ç –±—ñ—Ä–Ω–µ—à–µ —Ñ–∞–π–ª–¥—ã –∞–≤—Ç–æ–º–∞—Ç—Ç—ã —Ç“Ø—Ä–¥–µ –∂“Ø–∫—Ç–µ–ø –∞–ª–¥—ã–ë“±–ª —Å–∞–π—Ç –±—ñ—Ä–Ω–µ—à–µ —Ñ–∞–π–ª–¥—ã –∞–≤—Ç–æ–º–∞—Ç—Ç—ã —Ç“Ø—Ä–¥–µ –∂“Ø–∫—Ç–µ–ø –∞–ª—É“ì–∞ ”ô—Ä–µ–∫–µ—Ç –∂–∞—Å–∞–¥—ã–ñ“Ø–∫—Ç–µ—É –±“±“ì–∞—Ç—Ç–∞–ª–¥—ã–ë—ñ—Ä–Ω–µ—à–µ —Ñ–∞–π–ª–¥–∞—Ä–¥—ã –∞–≤—Ç–æ–º–∞—Ç—Ç—ã —Ç“Ø—Ä–¥–µ –∂“Ø–∫—Ç–µ–ø –∞–ª—É“ì–∞ —Ä“±“õ—Å–∞—Ç –µ—Ç—É–¥—ñ –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–¥–∞ –±—ñ—Ä–Ω–µ—à–µ —Ñ–∞–π–ª–¥—ã –∞–≤—Ç–æ–º–∞—Ç—Ç—ã —Ç“Ø—Ä–¥–µ –∂“Ø–∫—Ç–µ—É –∞–ª—É–¥—ã –±–ª–æ–∫—Ç–∞—É–ë–ª–æ–∫—Ç–∞–ª“ì–∞–Ω "cookie" —Ñ–∞–π–ª–¥–∞—Ä—ã"Cookie" —Ñ–∞–π–ª–¥–∞—Ä—ã–Ω –æ—Ä–Ω–∞—Ç—É–ë“±–ª –±–µ—Ç–∫–µ cookie —Ñ–∞–π–ª–¥–∞—Ä—ã–Ω –æ—Ä–Ω–∞—Ç—É“ì–∞ —Ç—ã–π—ã–º —Å–∞–ª—ã–Ω“ì–∞–Ω.–ë“±–ª –±–µ—Ç "cookie" —Ñ–∞–π–ª–¥–∞—Ä—ã–Ω –æ—Ä–Ω–∞—Ç—Ç—ã.Cookie —Ñ–∞–π–ª–¥–∞—Ä—ã –º–µ–Ω –±–∞—Å“õ–∞ —Å–∞–π—Ç –¥–µ—Ä–µ–∫—Ç–µ—Ä—ñ–Ω –∫”©—Ä—Å–µ—Ç—É–°—É—Ä–µ—Ç—Ç–µ—Ä–¥—ñ –±–ª–æ–∫—Ç–∞–ª“ì–∞–Ω–ö–µ—Å–∫—ñ–Ω–¥–µ—Ä –æ—Å—ã –±–µ—Ç—Ç–µ –±“±“ì–∞—Ç—Ç–∞–ª–¥—ã.”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–∞ "cookie" —Ñ–∞–π–ª–¥–∞—Ä—ã–Ω –æ—Ä–Ω–∞—Ç—É“ì–∞ —Ä“±“õ—Å–∞—Ç –µ—Ç—É”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–∞ —Å—É—Ä–µ—Ç—Ç–µ—Ä–¥—ñ –∫”©—Ä—Å–µ—Ç—É–≥–µ —Ä“±“õ—Å–∞—Ç –µ—Ç—É"Cookie" —Ñ–∞–π–ª–¥–∞—Ä—ã–Ω –±–ª–æ–∫—Ç–∞—É–¥—ã –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É"Cookie" —Ñ–∞–π–ª–¥–∞—Ä—ã–Ω–∞ —Ä“±“õ—Å–∞—Ç –±–µ—Ä—É–¥—ñ –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–¥–∞ "cookie" —Ñ–∞–π–ª–¥–∞—Ä—ã–Ω –±–ª–æ–∫—Ç–∞—É–°—É—Ä–µ—Ç—Ç–µ—Ä–¥—ñ –±–ª–æ–∫—Ç–∞—É–¥—ã –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É–û—Å—ã –±–µ—Ç—Ç–µ “õ–∞–ª“õ—ã–º–∞–ª—ã —Ç–µ—Ä–µ–∑–µ–ª–µ—Ä –±–ª–æ–∫—Ç–∞–ª“ì–∞–Ω.“ö–∞–ª“õ—ã–º–∞–ª—ã —Ç–µ—Ä–µ–∑–µ–ª–µ—Ä –±–ª–æ–∫—Ç–∞–ª“ì–∞–Ω:”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–∞ “õ–∞–ª“õ—ã–º–∞–ª—ã –º”ô–∑—ñ—Ä–ª–µ—Ä–≥–µ –∂”ô–Ω–µ –±–∞“ì—ã—Ç—ã–Ω ”©–∑–≥–µ—Ä—Ç—É ”ô—Ä–µ–∫–µ—Ç—ñ–Ω–µ —Ä“±“õ—Å–∞—Ç –µ—Ç—É–ë–ª–æ–∫—Ç–∞—É–¥—ã –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–∞ –∫–∞–º–µ—Ä–∞ –º–µ–Ω –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É“ì–∞ —Ä“±“õ—Å–∞—Ç –µ—Ç—É”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É“ì–∞ —Ä“±“õ—Å–∞—Ç –µ—Ç—É”ò—Ä“õ–∞—à–∞–Ω $1 —Å–∞–π—Ç—ã–Ω–∞ –∫–∞–º–µ—Ä–∞“ì–∞ –∫—ñ—Ä—É–≥–µ —Ä“±“õ—Å–∞—Ç –µ—Ç—É–ï–≥–µ—Ä $1 —Å–∞–π—Ç—ã –∫–∞–º–µ—Ä–∞ –º–µ–Ω –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å“õ—ã—Å—ã –∫–µ–ª—Å–µ, —Å“±—Ä–∞—É–ï–≥–µ—Ä $1 —Å–∞–π—Ç—ã –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ –∫—ñ—Ä–≥—ñ—Å—ñ –∫–µ–ª—Å–µ, —Å“±—Ä–∞—É–ï–≥–µ—Ä $1 —Å–∞–π—Ç—ã –∫–∞–º–µ—Ä–∞“ì–∞ –∫—ñ—Ä–≥—ñ—Å—ñ –∫–µ–ª—Å–µ, —Å“±—Ä–∞—É”ò—Ä“õ–∞—à–∞–Ω –∫–∞–º–µ—Ä–∞ –º–µ–Ω –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É —Ä“±“õ—Å–∞—Ç—ã–Ω –±–ª–æ–∫—Ç–∞—É”ò—Ä“õ–∞—à–∞–Ω –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—Ç—ã –±–ª–æ–∫—Ç–∞—É–ö–∞–º–µ—Ä–∞“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—Ç—ã ”ô—Ä“õ–∞—à–∞–Ω –±–ª–æ–∫—Ç–∞—É–ö–∞–º–µ—Ä–∞ –º–µ–Ω –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É –º“Ø–º–∫—ñ–Ω–¥—ñ–≥—ñ–Ω –±–ª–æ–∫—Ç–∞—É–¥—ã –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É–ú–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É –º“Ø–º–∫—ñ–Ω–¥—ñ–≥—ñ–Ω –±–ª–æ–∫—Ç–∞—É–¥—ã –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É–ö–∞–º–µ—Ä–∞“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É ”ô—Ä–µ–∫–µ—Ç—ñ–Ω –±–ª–æ–∫—Ç–∞—É–¥—ã –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É–û—Å—ã $1 —Å–∞–π—Ç—ã–Ω–∞ –∫–∞–º–µ—Ä–∞ –º–µ–Ω –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É“ì–∞ —Ä“±“õ—Å–∞—Ç –µ—Ç—É–¥—ñ –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É$1 —Å–∞–π—Ç—ã–Ω–∞ –∫–∞–º–µ—Ä–∞“£—ã–∑–¥—ã –ø–∞–π–¥–∞–ª–∞–Ω—É“ì–∞ –∂”ô–Ω–µ –∂—ã–ª–∂—ã—Ç—É“ì–∞ –∂”ô–Ω–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–¥—ã –ø–∞–π–¥–∞–ª–∞–Ω—É“ì–∞ —Ä“±“õ—Å–∞—Ç –µ—Ç—É–û—Å—ã $1 —Å–∞–π—Ç—ã–Ω–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω“ì–∞ “õ–∞—Ç—ã–Ω–∞—Å—É —Ä“±“õ—Å–∞—Ç—ã–Ω –±–µ—Ä—É–¥—ñ –∂–∞–ª“ì–∞—Å—Ç—ã—Ä—É–û—Å—ã $1 —Å–∞–π—Ç—ã–Ω–∞ –∫–∞–º–µ—Ä–∞“ì–∞ –∫—ñ—Ä—É–≥–µ — as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed
         * by default, and MAY live in the cache long after they have expired.
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * Must be an integer number of ms. If set to 0, this indicates "no TTL"
         *
         * @default 0
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         * Note that this may significantly degrade performance,
         * especially if the cache is storing a large number of items.
         * It is almost always best to just leave the stale items in
         * the cache, and let them fall out as new items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * @default false
         */
        ttlAutopurge?: boolean;
        /**
         * Update the age of items on {@link LRUCache#get}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnGet?: boolean;
        /**
         * Update the age of items on {@link LRUCache#has}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the cache.
         * This can be handy if you want to close file descriptors or do other
         * cleanup tasks when items are no longer accessible. Called with `key,
         * value`.  It's called before actually removing the item from the
         * internal cache, so it is *NOT* safe to re-add them.
         *
         * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after
         * they have been full removed, when it is safe to add them back to the
         * cache.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when
         * setting a new value for an existing key (ie, when updating a value
         * rather than inserting a new value).  Note that the TTL value is
         * _always_ set (if provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         */
        noUpdateTTL?: boolean;
        /**
         * If you wish to track item size, you must provide a maxSize
         * note that we still will only keep up to max *actual items*,
         * if max is set, so size tracking may cause fewer than max items
         * to be stored.  At the extreme, a single item of maxSize size
         * will cause everything else in the cache to be dropped when it
         * is added.  Use with caution!
         *
         * Note also that size tracking can negatively impact performance,
         * though for most cases, only minimally.
         */
        maxSize?: Size;
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link LRUCache#set} or returned by a
         * {@link OptionsBase.fetchMethod}, then it will not be stored in the
         * cache.
         */
        maxEntrySize?: Size;
        /**
         * A function that returns a number indicating the item's size.
         *
         * If not provided, and {@link OptionsBase.maxSize} or
         * {@link OptionsBase.maxEntrySize} are set, then all
         * {@link LRUCache#set} calls **must** provide an explicit
         * {@link SetOptions.size} or sizeCalculation param.
         */
        sizeCalculation?: SizeCalculator<K, V>;
        /**
         * Method that provides the implementation for {@link LRUCache#fetch}
         */
        fetchMethod?: Fetcher<K, V, FC>;
        /**
         * Set to true to suppress the deletion of stale data when a
         * {@link OptionsBase.fetchMethod} returns a rejected promise.
         */
        noDeleteOnFetchRejection?: boolean;
        /**
         * Do not delete stale items when they are retrieved with
         * {@link LRUCache#get}.
         *
         * Note that the `get` return value will still be `undefined`
         * unless {@link OptionsBase.allowStale} is true.
         */
        noDeleteOnStaleGet?: boolean;
        /**
         * Set to true to allow returning stale data when a
         * {@link OptionsBase.fetchMethod} throws an error or returns a rejected
         * promise.
         *
         * This differs from using {@link OptionsBase.allowStale} in that stale
         * data will ONLY be returned in the case that the
         * {@link LRUCache#fetch} fails, not any other times.
         */
        allowStaleOnFetchRejection?: boolean;
        /**
         * Set to true to return a stale value from the cache when the
         * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`
         * event, whether user-triggered, or due to internal cache behavior.
         *
         * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying
         * {@link OptionsBase.fetchMethod} will still be considered canceled, and
         * any value it returns will be ignored and not cached.
         *
         * Caveat: since fetches are aborted when a new value is explicitly
         * set in the cache, this can lead to fetch returning a stale value,
         * since that was the fallback value _at the moment the `fetch()` was
         * initiated_, even though the new updated value is now present in
         * the cache.
         *
         * For example:
         *
         * ```ts
         * const cache = new LRUCache<string, any>({
         *   ttl: 100,
         *   fetchMethod: async (url, oldValue, { signal }) =>  {
         *     const res = await fetch(url, { signal })
         *     return await res.json()
         *   }
         * })
         * cache.set('https://example.com/', { some: 'data' })
         * // 100ms go by...
         * const result = cache.fetch('https://example.com/')
         * cache.set('https://example.com/', { other: 'thing' })
         * console.log(await result) // { some: 'data' }
         * console.log(cache.get('https://example.com/')) // { other: 'thing' }
         * ```
         */
        allowStaleOnFetchAbort?: boolean;
        /**
         * Set to true to ignore the `abort` event emitted by the `AbortSignal`
         * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls are not
         * immediately resolved or rejected when they are aborted, and instead
         * take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort: boolean;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals<K extends {}, V extends {}, FC extends unknown = unknown>(c: LRUCache<K, V, FC>): {
        starts: ZeroArray | undefined;
        ttls: ZeroArray | undefined;
        sizes: ZeroArray | undefined;
        keyMap: Map<K, number>;
        keyList: (K | undefined)[];
        valList: (V | BackgroundFetch<V> | undefined)[];
        next: NumberArray;
        prev: NumberArray;
        readonly head: Index;
        readonly tail: Index;
        free: StackLike;
        isBackgroundFetch: (p: any) => boolean;
        backgroundFetch: (k: K, index: number | undefined, options: LRUCache.FetchOptions<K, V, FC>, context: any) => BackgroundFetch<V>;
        moveToTail: (index: number) => void;
        indexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        rindexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        isStale: (index: number | undefined) => boolean;
    };
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize(): LRUCache.Count;
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize(): LRUCache.Size;
    /**
     * The number of items stored in the cache (read-only)
     */
    get size(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined;
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose(): LRUCache.Disposer<K, V> | undefined;
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter(): LRUCache.Disposer<K, V> | undefined;
    constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>);
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key: K): number;
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    entries(): Generator<[K, V], void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    rentries(): Generator<(K | V | BackgroundFetch<V> | undefined)[], void, unknown>;
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    keys(): Generator<K, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    rkeys(): Generator<K, void, unknown>;
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    values(): Generator<V, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    rvalues(): Generator<V | BackgroundFetch<V> | undefined, void, unknown>;
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator](): Generator<[K, V], void, unknown>;
    /**
     * A String value that is used in the creation of the default string description of an object.
     * Called by the built-in method Object.prototype.toString.
     */
    [Symbol.toStringTag]: string;
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale(): boolean;
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
     * single key. Always returns stale values, if their info is found in the
     * cache, so be sure to check for expired TTLs if relevant.
     */
    info(key: K): LRUCache.Entry<V> | undefined;
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump(): [K, LRUCache.Entry<V>][];
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr: [K, LRUCache.Entry<V>][]): void;
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k: K, v: V | BackgroundFetch<V> | undefined, setOptions?: LRUCache.SetOptions<K, V, FC>): this;
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop(): V | undefined;
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k: K, hasOptions?: LRUCache.HasOptions<K, V, FC>): boolean;
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k: K, peekOptions?: LRUCache.PeekOptions<K, V, FC>): V | undefined;
    /**
     * Make an asynchronous cached fetch using the
     * {@link LRUCache.OptionsBase.fetchMethod} function.
     *
     * If multiple fetches for the same key are issued, then they will all be
     * coalesced into a single call to fetchMethod.
     *
     * Note that this means that handling options such as
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},
     * {@link LRUCache.FetchOptions.signal},
     * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be
     * determined by the FIRST fetch() call for a given key.
     *
     * This is a known (fixable) shortcoming which will be addresed on when
     * someone complains about it, as the fix would involve added complexity and
     * may not be worth the costs for this edge case.
     */
    fetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<undefined | V>;
    fetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<undefined | V>;
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k: K, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k: K): boolean;
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear(): void;
}
//# sourceMappingURL=index.d.ts.map