

import {IdentifierRole} from "../parser/tokenizer";
import {TokenType as tt} from "../parser/tokenizer/types";


import Transformer from "./Transformer";

/**
 * Implementation of babel-plugin-transform-react-display-name, which adds a
 * display name to usages of React.createClass and createReactClass.
 */
export default class ReactDisplayNameTransformer extends Transformer {
  constructor(
     rootTransformer,
     tokens,
     importProcessor,
     options,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.options = options;;
  }

  process() {
    const startIndex = this.tokens.currentIndex();
    if (this.tokens.identifierName() === "createReactClass") {
      const newName =
        this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
      if (newName) {
        this.tokens.replaceToken(`(0, ${newName})`);
      } else {
        this.tokens.copyToken();
      }
      this.tryProcessCreateClassCall(startIndex);
      return true;
    }
    if (
      this.tokens.matches3(tt.name, tt.dot, tt.name) &&
      this.tokens.identifierName() === "React" &&
      this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass"
    ) {
      const newName = this.importProcessor
        ? this.importProcessor.getIdentifierReplacement("React") || "React"
        : "React";
      if (newName) {
        this.tokens.replaceToken(newName);
        this.tokens.copyToken();
        this.tokens.copyToken();
      } else {
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.tokens.copyToken();
      }
      this.tryProcessCreateClassCall(startIndex);
      return true;
    }
    return false;
  }

  /**
   * This is called with the token position at the open-paren.
   */
   tryProcessCreateClassCall(startIndex) {
    const displayName = this.findDisplayName(startIndex);
    if (!displayName) {
      return;
    }

    if (this.classNeedsDisplayName()) {
      this.tokens.copyExpectedToken(tt.parenL);
      this.tokens.copyExpectedToken(tt.braceL);
      this.tokens.appendCode(`displayName: '${displayName}',`);
      this.rootTransformer.processBalancedCode();
      this.tokens.copyExpectedToken(tt.braceR);
      this.tokens.copyExpectedToken(tt.parenR);
    }
  }

   findDisplayName(startIndex) {
    if (startIndex < 2) {
      return null;
    }
    if (this.tokens.matches2AtIndex(startIndex - 2, tt.name, tt.eq)) {
      // This is an assignment (or declaration) and the LHS is either an identifier or a member
      // expression ending in an identifier, so use that identifier name.
      return this.tokens.identifierNameAtIndex(startIndex - 2);
    }
    if (
      startIndex >= 2 &&
      this.tokens.tokens[startIndex - 2].identifierRole === IdentifierRole.ObjectKey
    ) {
      // This is an object literal value.
      return this.tokens.identifierNameAtIndex(startIndex - 2);
    }
    if (this.tokens.matches2AtIndex(startIndex - 2, tt._export, tt._default)) {
      return this.getDisplayNameFromFilename();
    }
    return null;
  }

   getDisplayNameFromFilename() {
    const filePath = this.options.filePath || "unknown";
    const pathSegments = filePath.split("/");
    const filename = pathSegments[pathSegments.length - 1];
    const dotIndex = filename.lastIndexOf(".");
    const baseFilename = dotIndex === -1 ? filename : filename.slice(0, dotIndex);
    if (baseFilename === "index" && pathSegments[pathSegments.length - 2]) {
      return pathSegments[pathSegments.length - 2];
    } else {
      return baseFilename;
    }
  }

  /**
   * We only want to add a display name when this is a function call containing
   * one argument, which is an object literal without `displayName` as an
   * existing key.
   */
   classNeedsDisplayName() {
    let index = this.tokens.currentIndex();
    if (!this.tokens.matches2(tt.parenL, tt.braceL)) {
      return false;
    }
    // The block starts on the {, and we expect any displayName key to be in
    // that context. We need to ig∞–±–æ—á–∏–º –æ–±–ª–∞—Å—Ç—è–º–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏–°–æ–∑–¥–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–π —Ä–∞–±–æ—á–µ–π –æ–±–ª–∞—Å—Ç–∏–ò–¥–µ—Ç –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞‚Ä¶–î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ —Ä–∞–±–æ—á–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π $1 –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏. –ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–¥–∞–ª–∏—Ç—å —Ä–∞–±–æ—á—É—é –æ–±–ª–∞—Å—Ç—å, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é.$1 –∏–∑ $2 —Ä–∞–±–æ—á–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –≤–æ –≤—Ä–µ–º—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏.–£–¥–∞–ª–∏—Ç–µ —Ä–∞–±–æ—á—É—é –æ–±–ª–∞—Å—Ç—å, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é{NUM_INVITES, plural,
    =0 {–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è}
    =1 {{NUM_INVITES} –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—Å–µ—Ö –≤–∞—à–∏—Ö —Ä–∞–±–æ—á–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π}
    one {{NUM_INVITES} –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—Å–µ—Ö –≤–∞—à–∏—Ö —Ä–∞–±–æ—á–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π}
    few {{NUM_INVITES} –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –≤—Å–µ—Ö –≤–∞—à–∏—Ö —Ä–∞–±–æ—á–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π}
    many {{NUM_INVITES} –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π –¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—Å–µ—Ö –≤–∞—à–∏—Ö —Ä–∞–±–æ—á–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π}
    other {{NUM_INVITES} –ø—Ä–∏–≥