ò–∞. –ü—Ä–∏—ò–∞–≤–∏—Ç–µ —Å–µ –∏ —É–∫—ô—É—á–∏—Ç–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—ò—É –¥–∞ –±–∏—Å—Ç–µ –∏–∑–±—Ä–∏—Å–∞–ª–∏ —Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–µ —Å–∞ —Å–≤–∏—Ö —É—Ä–µ—í–∞—ò–∞.–ò–∑–∞–±—Ä–∞–Ω–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–µ –∫–æ—ò–µ –∏–∑–±—Ä–∏—à–µ—Ç–µ –±–∏—õ–µ —É–∫–ª–æ—ö–µ–Ω–µ —Å–∞ —Å–≤–∏—Ö –≤–∞—à–∏—Ö —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–æ–≤–∞–Ω–∏—Ö —É—Ä–µ—í–∞—ò–∞. –ò—Å–∫—ô—É—á–∏—Ç–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—ò—É –¥–∞ –±–∏—Å—Ç–µ –∏–∑–±—Ä–∏—Å–∞–ª–∏ –æ–≤–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–µ —Å–∞–º–æ —Å–∞ –æ–≤–æ–≥ —É—Ä–µ—í–∞—ò–∞.–ê–∫–æ —É–∫—ô—É—á–∏—Ç–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—ò—É, –ø–æ–¥–∞—Ü–∏ –æ –ª–∏—á–Ω–æ—Å—Ç–∏ —Å–∞ —Å–≤–∏—Ö —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–æ–≤–∞–Ω–∏—Ö —É—Ä–µ—í–∞—ò–∞ –±–∏—õ–µ –∏–∑–±—Ä–∏—Å–∞–Ω–∏. –î–∞ –±–∏—Å—Ç–µ –∏—Ö –∏–∑–±—Ä–∏—Å–∞–ª–∏ —Å–∞–º–æ —Å–∞ –æ–≤–æ–≥ —É—Ä–µ—í–∞—ò–∞, –æ–¥—ò–∞–≤–∏—Ç–µ —Å–µ –∏–∑ –ø—Ä–µ–≥–ª–µ–¥–∞—á–∞ Microsoft Edge.–î–∞ –±–∏—Å—Ç–µ –∏–∑–∞–±—Ä–∞–ª–∏ —Å—Ç–∞–≤–∫–µ —Å–∞ –æ–≤–µ –ª–∏—Å—Ç–µ, –∫–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –¥—É–≥–º–µ ‚Äû–û—Ç–∫–∞–∂–∏‚Äú –¥–∞ –±–∏—Å—Ç–µ –æ–±—Ä–∏—Å–∞–ª–∏ –∏–∑–∞–±—Ä–∞–Ω–µ —Å—Ç–∞–≤–∫–µ —Å–∞ –¥—Ä—É–≥–µ –ª–∏—Å—Ç–µ.–ò–∑–∞–±–µ—Ä–∏ —Å–≤–µ–ò–∑–∞–±–µ—Ä–∏ —Å–≤–µ $1–ò–∑–∞–±–µ—Ä–∏—Ç–µ –ø—Ä–æ—Ñ–∏–ª $1–ò–∑–∞–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø—É –ø–æ–¥ –∏–º–µ–Ω–æ–º $1–ò–∑–∞–±—Ä–∞–Ω–∞ —ò–µ –≥—Ä—É–ø–∞ –ø–æ–¥ –Ω–∞–∑–∏–≤–æ–º $1. –ü—Ä–∏—Ç–∏—Å–Ω–∏—Ç–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏—ò—É —Ç–∞—Å—Ç–µ—Ä–∞ Shift –ø–ª—É—Å Tab –¥–∞ –±–∏—Å—Ç–µ —Å–µ –∫—Ä–µ—Ç–∞–ª–∏ –¥–æ –¥—É–≥–º–∞–¥–∏ –∑–∞ –±—Ä–∏—Å–∞—ö–µ –∏ –æ—Ç–∫–∞–∑–∏–≤–∞—ö–µ.–û–ø–æ–∑–≤–∞–Ω —ò–µ –∏–∑–±–æ—Ä –≥—Ä—É–ø–µ –ø–æ–¥ –∏–º–µ–Ω–æ–º $1.–ü—Ä–æ–º–µ–Ω–∞ –ª–æ–∑–∏–Ω–∫–µ –æ–≤–¥–µ –∞–∂—É—Ä–∏—Ä–∞ —ò–µ —Å–∞–º–æ –Ω–∞ Microsoft –Ω–∞–ª–æ–≥. –ü—Ä–æ–≤–µ—Ä–∏—Ç–µ –¥–∞ –ª–∏ —Å–µ –ª–æ–∑–∏–Ω–∫–∞ –∫–æ—ò—É –æ–≤–¥–µ —á—É–≤–∞—Ç–µ –ø–æ–¥—É–¥–∞—Ä–∞ —Å–∞ –ª–æ–∑–∏–Ω–∫–æ–º –∑–∞–ê–∫–æ –æ–≤–¥–µ –¥–æ–¥–∞—Ç–µ –ª–æ–∑–∏–Ω–∫—É, –æ–Ω–∞ —õ–µ –±–∏—Ç–∏ —Å–∞—á—É–≤–∞–Ω–∞ —Å–∞–º–æ –Ω–∞ –≤–∞—à–µ–º Microsoft –Ω–∞–ª–æ–≥—É. –£–≤–µ—Ä–∏—Ç–µ —Å–µ –¥–∞ –ª–æ–∑–∏–Ω–∫–∞ –∫–æ—ò—É –æ–≤–¥–µ —Å–∞—á—É–≤–∞—Ç–µ –æ–¥–≥–æ–≤–∞—Ä–∞ –≤–∞—à–æ—ò –ª–æ–∑–∏–Ω–∫–∏ –∑–∞ –≤–µ–± –ª–æ–∫–∞—Ü–∏—ò—É.–ü—Ä–æ–º–µ–Ω–∞ –ª–æ–∑–∏–Ω–∫–µ –æ–≤–¥–µ –∞–∂—É—Ä–∏—Ä–∞ —ò–µ —Å–∞–º–æ —É Microsoft Edge. –£–≤–µ—Ä–∏—Ç–µ —Å–µ –¥–∞ —Å–µ –ª–æ–∑–∏–Ω–∫–∞ –∫–æ—ò—É –æ–≤–¥–µ —Å–∞—á—É–≤–∞—Ç–µ –ø–æ–¥—É–¥–∞—Ä–∞ —Å–∞ –≤–∞—à–æ–º –ª–æ–∑–∏–Ω–∫–æ–º –∑–∞–ê–∫–æ –æ–≤–¥–µ –¥–æ–¥–∞—Ç–µ –ª–æ–∑–∏–Ω–∫—É, –æ–Ω–∞ —õ–µ –±–∏—Ç–∏ —Å–∞—á—É–≤–∞–Ω–∞ —Å–∞–º–æ —É Microsoft Edge. –£–≤–µ—Ä–∏—Ç–µ —Å–µ –¥–∞ –ª–æ–∑–∏–Ω–∫–∞ –∫–æ—ò—É –æ–≤–¥–µ —Å–∞—á—É–≤–∞—Ç–µ –æ–¥–≥–æ–≤–∞—Ä–∞ –≤–∞—à–æ—ò –ª–æ–∑–∏–Ω–∫–∏ –∑–∞ –≤–µ–± –ª–æ–∫–∞—Ü–∏—ò—É.–ü—Ä–µ–≥–ª–µ–¥–∞—á Microsoft Edge —õ–µ —Å–∞—á—É–≤–∞—Ç–∏ –æ–≤—É –ª–æ–∑–∏–Ω–∫—É —É Microsoft –Ω–∞–ª–æ–≥—É–õ–æ–∑–∏–Ω–∫–∞ —ò–µ –¥–æ–¥–∞—Ç–∞–ü—Ä–∏–∫–∞–∂–∏—Ç–µ —Å–∞—á—É–≤–∞–Ω–µ –ª–æ–∑–∏–Ω–∫–µ –∏ —É–ø—Ä–∞–≤—ô–∞—ò—Ç–µ —ö–∏–º–∞ —É –æ–∫–≤–∏—Ä—É <a is="action-link" href="$1" target="_blank">Microsoft –Ω–∞–ª–æ–≥–∞</a>–ü–æ–Ω—É–¥–∏ —á—É–≤–∞—ö–µ –ª–æ–∑–∏–Ω–∫–∏–ü—Ä–µ—Ç—Ä–∞–≥–∞ –ª–æ–∑–∏–Ω–∫–∏–î–µ—Ç–∞—ô–∏ –æ –ª–æ–∑–∏–Ω—Ü–∏–î–µ—Ç–∞—ô–∏–ö–æ—Ä–∏—Å–Ω–∏—á–∫–æ –∏–º–µ–õ–æ–∑–∏–Ω–∫–∞–õ–æ–∑–∏–Ω–∫–∞ —ò–µ –∏–∑–±—Ä–∏—Å–∞–Ω–∞–í–∞—à–µ –ª–æ–∑–∏–Ω–∫–µ –º–æ–∂–µ –¥–∞ –≤–∏–¥–∏ —Å–≤–∞–∫–æ –∫–æ –≤–∏–¥–∏ –∏–∑–≤–µ–∑–µ–Ω—É –¥–∞—Ç–æ—Ç–µ–∫—É.–ù–∏—ò–µ –º–æ–≥—É—õ–µ –∏–∑–≤–µ—Å—Ç–∏ –ª–æ–∑–∏–Ω–∫–µ —É —Ñ–∞—Å—Ü–∏–∫–ª—É ‚Äû$1‚Äú–ò–∑–≤–æ–∑ –∞–¥—Ä–µ—Å–∞–ò–∑–≤–µ–∑–∏ –ª–∏—á–Ω–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–µ–ò–∑–≤–µ–∑–∏ –æ—Å–Ω–æ–≤–Ω–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–µ–ó–∞—à—Ç–∏—Ç–∏—Ç–µ –ø–æ—Å—Ç–∞–≤–∫—É –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ–≥ –ø—Ä–µ–≥–ª–µ–¥–∞—á–∞–ê–∫–æ —É–∫—ô—É—á–∏—Ç–µ –æ–≤–∞—ò –ø—Ä–µ–∫–ª–æ–ø–Ω–∏–∫, –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–∏ –ø—Ä–µ–≥–ª–µ–¥–∞—á —õ–µ —Å–µ –ø—Ä–µ–±–∞—Ü–∏—Ç–∏ –Ω–∞ Microsoft Edge –∞–∫–æ —Å–µ –æ—Ç–∫—Ä–∏—ò–µ –ø—Ä–æ–º–µ–Ω–∞ –ø–æ—Å—Ç–∞–≤–∫–µ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ–≥ –ø—Ä–µ–≥–ª–µ–¥–∞—á–∞Canary –≤–µ—Ä–∑–∏—ò–µ –º–æ–≥—É –±–∏—Ç–∏ –Ω–µ—Å—Ç–∞–±–∏–ª–Ω–µ ‚Äì –æ–Ω–µ —Å–µ –∏–∑–¥–∞—ò—É —Å–≤–∞–∫–æ–¥–Ω–µ–≤–Ω–æ —Ä–∞–¥–∏ –ø—Ä–æ–≤–µ—Ä–µ –ø–æ–ø—Ä–∞–≤–∫–∏ –≥—Ä–µ—à–∞–∫–∞ –∏ —Ç–µ—Å—Ç–∏—Ä–∞—ö–∞ –ø–æ—Ç–ø—É–Ω–æ –Ω–æ–≤–∏—Ö —Ñ—É–Ω–∫—Ü–∏—ò–∞–û–≤–∏–º —õ–µ—Ç–µ –æ–±—Ä–∏—Å–∞—Ç–∏ –ø–æ–¥–∞—Ç–∫–µ —Å–∞ —Å–≤–∏—Ö —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–æ–≤–∞–Ω–∏—Ö —É—Ä–µ—í–∞—ò–∞ –ø—Ä–∏—ò–∞–≤—ô–µ–Ω–∏—Ö –Ω–∞ $1.–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—ò–∞ —ò–µ –∏—Å–∫—ô—É—á–µ–Ω–∞. –ö–∞–¥–∞ —É–∫—ô—É—á–∏—Ç–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—ò—É, –æ–≤–∏ –ø–æ–¥–∞—Ü–∏ —õ–µ –±–∏—Ç–∏ –æ–±—Ä–∏—Å–∞–Ω–∏ –Ω–∞ —Å–≤–∏–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–æ–≤–∞–Ω–∏–º —É—Ä–µ—í–∞—ò–∏–º–∞ –ø—Ä–∏—ò–∞–≤—ô–µ–Ω–∏–º –Ω–∞ $1.–ø—Ä–≤–æ —Å–µ –æ–¥—ò–∞–≤–∏—Ç–µ–ò–∑–∞–±–µ—Ä–∏—Ç–µ —Å–∞–¥—Ä–∂–∞—ò –∑–∞ –±—Ä–∏—Å–∞—ö–µ–°–≤–∏ –ø–æ–¥–∞—Ü–∏ –∏–∑ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–µ –≤–µ—Ä–∑–∏—ò–µ –ø—Ä–µ–≥–ª–µ–¥–∞—á–∞ Microsoft Edge–£–∫—ô—É—á—É—ò–µ –∏—Å—Ç–æ—Ä–∏—ò—É, —Ñ–∞–≤–æ—Ä–∏—Ç–µ, –ª–æ–∑–∏–Ω–∫–µ –∏ —ò–æ—à —Ç–æ–≥–∞.–î–æ–∑–≤–æ–ª–µ –∑–∞ –ª–æ–∫–∞—Ü–∏—ò–µMedia Foundation –ø–æ–¥–∞—Ü–∏–£–∫—ô—É—á—É—ò–µ –ª–∏—Ü–µ–Ω—Ü–µ, —Ü–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–µ, —Ç–∞—Å—Ç–µ—Ä–µ –∏ —ò–æ—à –º–Ω–æ–≥–æ —Ç–æ–≥–∞. –ë—Ä–∏—à–µ –ø–æ–¥–∞—Ç–∫–µ –∫–∞–¥–∞ —Å–µ –ø–æ–Ω–æ–≤–æ –ø–æ–∫—Ä–µ–Ω–µ –ø—Ä–µ–≥–ª–µ–¥–∞—á.–û–¥–∞–±–µ—Ä–∏—Ç–µ —à—Ç–∞ —õ–µ –±–∏—Ç–∏ –æ–±—Ä–∏—Å–∞–Ω–æ —Å–≤–∞–∫–∏ –ø—É—Ç –∫–∞–¥–∞ –∑–∞—Ç–≤–æ—Ä–∏—Ç–µ –ø—Ä–µ–≥–ª–µ–¥–∞—á–û–±—Ä–∏—à–∏—Ç–µ –ø–æ–¥–∞—Ç–∫–µ –æ –ø—Ä–µ–≥–ª–µ–¥–∞—ö—É –∑–∞ Internet Explorer–û–¥–º–∞—Ö –æ–±—Ä–∏—à–∏ –ø–æ–¥–∞—Ç–∫–µ –ø—Ä–µ–≥–ª–µ–¥–∞—ö–∞–û–±—Ä–∏—à–∏—Ç–µ –ø–æ–¥–∞—Ç–∫–µ –æ –ø—Ä–µ–≥–ª–µ–¥–∞—ö—É –∑–∞ —Ä–µ–∂–∏–º –ø—Ä–µ–≥–ª–µ–¥–∞—á–∞ Internet Explorer–¢–æ –æ–±—É—Ö–≤–∞—Ç–∞ –∏—Å—Ç–æ—Ä–∏—ò—É, –ª–æ–∑–∏–Ω–∫–µ, –∫–æ–ª–∞—á–∏—õ–µ –∏ —ò–æ—à —Ç–æ–≥–∞. –û–¥–∞–±—Ä–∞–Ω–∏ –ø–æ–¥–∞—Ü–∏ –∑–∞ Internet Explorer –∏ —Ä–µ–∂–∏–º –ø—Ä–µ–≥–ª–µ–¥–∞—á–∞ —õ–µ –±–∏—Ç–∏ –∏–∑–±—Ä–∏—Å–∞–Ω–∏.–û–¥–∞–±–µ—Ä–∏—Ç–µ —à—Ç–∞ –∂–µ–ª–∏—Ç–µ –¥–∞ –æ–±—Ä–∏—à–µ—Ç–µ –∑–∞ Internet Explorer–û–±—Ä–∏—à–∏—Ç–µ –æ–¥–∞–±—Ä–∞–Ω–µ –ø–æ–¥–∞—Ç–∫–µ –∑–∞ Internet Explorer –∏ —Ä–µ–∂–∏–º –ø—Ä–µ–≥–ª–µ–¥–∞—á–∞ Internet Explorer —Å–≤–∞–∫–∏ –ø—É—Ç –∫–∞–¥–∞ –∑–∞—Ç–≤–æ—Ä–∏—Ç–µ –ø—Ä–µ–≥–ª–µ–¥–∞—á Microsoft Edge–î–∞ –±–∏—Å—Ç–µ –æ–¥–∞–±—Ä–∞–ª–∏ —à—Ç–∞ –∂–µ–ª–∏—Ç–µ –¥–∞ –∏–∑–±—Ä–∏—à–µ—Ç–µ, –æ—Ç–≤–æ—Ä–∏—Ç–µ –º–µ–Ω–∏ $1.–∏–∑–±—Ä–∏—à–∏ –∏—Å—Ç–æ—Ä–∏—ò—É –ø—Ä–µ–≥–ª–µ–¥–∞—ö–∞–ü–æ—Ä–æ–¥–∏—Ü–∞–ü–æ—Ä–æ–¥–∏—á–Ω–∞ –±–µ–∑–±–µ–¥–Ω–æ—Å—Ç–ü–æ—á–Ω–∏ –æ–¥–º–∞—Ö–ò–¥–∏ –Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª–Ω—É —Ç–∞–±–ª—É –ø–æ—Ä–æ–¥–∏—Ü–µ–ü—Ä–µ—É–∑–º–∏ –æ–¥–º–∞—Ö–ø–æ—Ä–æ–¥–∏—á–Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª–Ω–∞ —Ç–∞–±–ª–∞–ü–æ–º–æ–∑–∏—Ç–µ –¥–∞ –≤–∞—à–∞ –ø–æ—Ä–æ–¥–∏—Ü–∞ –±—É–¥–µ –±–µ–∑–±–µ–¥–Ω–∏—ò–∞ —É–∑ Microsoft Edge–ü–æ–º–æ–∑–∏—Ç–µ –ø–æ—Ä–æ–¥–∏—Ü–∏ –¥–∞ —Å–∞—á—É–≤–∞ –±–µ–∑–±–µ–¥–Ω–æ—Å—Ç –Ω–∞ –º—Ä–µ–∂–∏–°–∞—á—É–≤–∞—ò—Ç–µ –±–µ–∑–±–µ–¥–Ω–æ—Å—Ç –Ω–∞ –≤–µ–±—É–°–≤–∞–∫–æ–º —ò–µ –ª–∞–∫—à–µ –¥–∞ –∏—Å—Ç—Ä–∞–∂—É—ò–µ –Ω–∞ –º—Ä–µ–∂–∏ —É–∑ –ø–æ—Ä–æ–¥–∏—á–Ω—É –≥—Ä—É–ø—É.–ö–æ—Ä–∏—Å—Ç–∏—Ç–µ –∫–æ–Ω—Ç—Ä–æ–ª–Ω—É —Ç–∞–±–ª—É –ø–æ—Ä–æ–¥–∏—Ü–µ –∑–∞ –±—Ä–∑–∏ –ø—Ä–∏—Å—Ç—É–ø –Ω–µ—á–∏—ò–∏–º –ø–æ—Å—Ç–∞–≤–∫–∞–º–∞ –∏–ª–∏ –¥–æ–¥–∞–≤–∞—ö–µ –Ω–æ–≤–æ–≥ —á–ª–∞–Ω–∞ –ø–æ—Ä–æ–¥–∏—Ü–µ –∫–∞–¥ –≥–æ–¥ –∂–µ–ª–∏—Ç–µ.–ö–æ—Ä–∏—Å—Ç–∏—Ç–µ –∫–æ–Ω—Ç—Ä–æ–ª–Ω—É —Ç–∞–±–ª—É –ø–æ—Ä–æ–¥–∏—Ü–µ –∑–∞ –±—Ä–∑–∏ –ø—Ä–∏—Å—Ç—É–ø –¥–æ–∫ —Å—É—Ä—Ñ—É—ò–µ—Ç–µ –≤–µ–±–æ–º. –ü—Ä–∏–∫–∞–∂–∏—Ç–µ —Å–≤–æ—ò—É –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç –∫–∞–¥–≥–æ–¥ –∂–µ–ª–∏—Ç–µ.–ü–æ—Ä–æ–¥–∏—á–Ω–µ —Ñ—É–Ω–∫—Ü–∏—ò–µ —É –ø—Ä–µ–≥–ª–µ–¥–∞—á—É Microsoft Edge–ü–æ—Ä–æ–¥–∏—á–Ω–µ —Ñ—É–Ω–∫—Ü–∏—ò–µ —É –ø—Ä–µ–≥–ª–µ–¥–∞—á—É Microsoft Edge*–ö–∞–∫–æ –¥–∞ –æ–±–µ–∑–±–µ–¥–∏—Ç–µ –¥–∞ —Å–≤–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—à–µ–ö–∞–∫–æ –¥–∞ –æ–±–µ–∑–±–µ–¥–∏—Ç–µ –¥–∞ —Å–≤–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—à–µ*–ö–∞–∫–æ –¥–∞ –¥–æ–±–∏—ò–µ—Ç–µ –Ω–∞—ò–±–æ—ô–µ –∏—Å–∫—É—Å—Ç–≤–æ —Å–∞ –∞–ø–ª–∏–∫–∞—Ü–∏—ò–æ–º ‚Äû–ü–æ—Ä–æ–¥–∏—á–Ω–∞ –±–µ–∑–±–µ–¥–Ω–æ—Å—Ç‚Äú–ö–∞–∫–æ –¥–∞ –¥–æ–±–∏—ò–µ—Ç–µ –Ω–∞—ò–±–æ—ô–µ –∏—Å–∫—É—Å—Ç–≤–æ —Å–∞ –∞–ø–ª–∏–∫–∞—Ü–∏—ò–æ–º ‚Äû–ü–æ—Ä–æ–¥–∏—á–Ω–∞ –±–µ–∑–±–µ–¥–Ω–æ—Å—Ç‚Äú*–§–∏–ª—Ç–µ—Ä–∏ —Å–∞–¥—Ä–∂–∞—ò–∞–§–∏–ª—Ç–µ—Ä–∏ —Å–∞–¥—Ä–∂–∞—ò–∞ $1–†–µ—à–∏—Ç–µ —Å–µ –ª–æ—à–∏—Ö —Å—Ç–≤–∞—Ä–∏ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞—ö–µ–º –Ω–µ–ø—Ä–∏–∫–ª–∞–¥–Ω–∏—Ö –≤–µ–± –ª–æ–∫–∞—Ü–∏—ò–∞ —É –ø—Ä–µ–≥–ª–µ–¥–∞—á—É Microsoft Edge –∏ –ø—Ä–µ—Ç—Ä–∞–≥–∞ —É —É—Å–ª—É–∑–∏ Bing.–ö–∞–¥–∞ —ò–µ —Ñ–∏–ª—Ç–µ—Ä –∑–∞ –ø—Ä–µ—Ç—Ä–∞–≥—É –∏ –≤–µ–± —É–∫—ô—É—á–µ–Ω, —Å–∞–¥—Ä–∂–∞—ò –∑–∞ –æ–¥—Ä–∞—Å–ª–µ —ò–µ –±–ª–æ–∫–∏—Ä–∞–Ω –∏ –ë–µ–∑–±–µ–¥–Ω–∞ –ø—Ä–µ—Ç—Ä–∞–≥–∞ —ò–µ –æ–º–æ–≥—É—õ–µ–Ω–∞ —É –ø—Ä–µ–≥–ª–µ–¥–∞—á—É Bing. –ú–æ–∂–µ—Ç–µ –¥–∞ –ø—Ä–∏–ª–∞–≥–æ–¥–∏—Ç–µ —Å–∞—ò—Ç–æ–≤–µ –∫–æ—ò–∏ —Å–µ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞—ò—É —Ç–∞–∫–æ —à—Ç–æ —õ–µ—Ç–µ –∏—Ö –¥–æ–¥–∞—Ç–∏ –Ω–∞ –ª–∏—Å—Ç—É ‚Äû–±–ª–æ–∫–∏—Ä–∞–Ω–∏‚Äú –∏–ª–∏ ‚Äû–¥–æ–∑–≤–æ—ô–µ–Ω–æ‚Äú.–ü–æ–¥–µ—à–∞–≤–∞—ö–µ —Ñ–∏–ª—Ç–µ—Ä–∞ —Å–∞–¥—Ä–∂–∞—ò–∞ –Ω–∞ —É—Ä–µ—í–∞—ò–∏–º–∞ –¥–µ—Ç–µ—Ç–∞–§–∏–ª—Ç–µ—Ä–∏ –∑–∞ —Å–∞–¥—Ä–∂–∞—ò —Ä–∞–¥–µ –Ω–∞ Windows 10, Xbox One –∏ Android —É—Ä–µ—í–∞—ò–∏–º–∞. –í–µ–±-–ª–æ–∫–∞—Ü–∏—ò–µ e incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit('abort', this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED])
            return false;
        if (this[EOF])
            throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC] ? defer : nodefer;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                this[FLUSH](true);
            /* c8 ignore stop */
            if (this[FLOWING])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
        if (this[FLOWING])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED])
            return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE])
            n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER] = [
                (this[ENCODING]
                    ? this[BUFFER].join('')
                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (this[OBJECTMODE])
            this[BUFFERSHIFT]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT]();
            else if (typeof c === 'string') {
                this[BUFFER][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH] -= n;
            }
            else {
                this[BUFFER][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER].length && !this[EOF])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING] || !this[PAUSED])
            this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED])
            return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER].length)
            this[FLUSH]();
        else if (this[EOF])
            this[MAYBE_EMIT_END]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
        return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] += 1;
        else
            this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
        else
            this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
            this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        this.emit('data', chunk);
        return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
        if (this[DESTROYED])
            return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
            opts.end = false;
        else
            opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end)
                dest.end();
        }
        else {
            // "as" here just ignores the WType, which pipes don't care about,
            // since they're only consuming from us, and writing to the dest
            this[PIPES].push(!opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC])
                defer(() => this[RESUME]());
            else
                this[RESUME]();
        }
        return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
        const p = this[PIPES].find(p => p.dest === dest);
        if (p) {
            if (this[PIPES].length === 1) {
                if (this[FLOWING] && this[DATALISTENERS] === 0) {
                    this[FLOWING] = false;
                }
                this[PIPES] = [];
            }
            else
                this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
        return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === 'data') {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
                this[RESUME]();
            }
        }
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
            super.emit('readable');
        }
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        }
        else if (ev === 'error' && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC])
                defer(() => h.call(this, this[EMITTED_ERROR]));
            else
                h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
        return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
        const ret = super.off(ev, handler);
        // if we previously had listeners, and now we don't, and we don't
        // have any pipes, then stop the flow, unless it's been explicitly
        // put in a discarded flowing state via stream.resume().
        if (ev === 'data') {
            this[DATALISTENERS] = this.listeners('data').length;
            if (this[DATALISTENERS] === 0 &&
                !this[DISCARDED] &&
                !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === 'data' || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER].length === 0 &&
            this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED])
                this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
        const data = args[0];
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' &&
            ev !== 'close' &&
            ev !== DESTROYED &&
            this[DESTROYED]) {
            return false;
        }
        else if (ev === 'data') {
            return !this[OBJECTMODE] && !data
                ? false
                : this[ASYNC]
                    ? (defer(() => this[EMITDATA](data)), true)
                    : this[EMITDATA](data);
        }
        else if (ev === 'end') {
            return this[EMITEND]();
        }
        else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED])
                return false;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        }
        else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners('error').length
                ? super.emit('error', data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]) {
            if (p.dest.write(data) === false)
                this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END])
            return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]) {
                    p.dest.write(data);
                }
                if (!this[DISCARDED])
                    super.emit('data', data);
            }
        }
        for (const p of this[PIPES]) {
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
        const buf = Object.assign([], {
            dataLength: 0,
        });
        if (!this[OBJECTMODE])
            buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', c => {
            buf.push(c);
            if (!this[OBJECTMODE])
                buf.dataLength += c.length;
        });
        await p;
        return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
        if (this[OBJECTMODE]) {
            throw new Error('cannot concat in objectMode');
        }
        const buf = await this.collect();
        return (this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength));
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
        return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
            this.on('error', er => reject(er));
            this.on('end', () => resolve());
        });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED])
            wc.ò–æ–º —É–ø—Ä–∞–≤—ô–∞ –≤–∞—à–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—ò–∞ –∑–∞ $1–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—ò—É —ò–µ –Ω–∞–º–µ—Ç–Ω—É–ª–∞ –≤–∞—à–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—ò–∞ –∑–∞ $1–ü—Ä–∏–ª–∞–≥–æ–¥–∏—Ç–µ –ø–æ—Å—Ç–∞–≤–∫–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—ò–µ.–ü–æ–º–æ–∑–∏—Ç–µ –Ω–∞–º –¥–∞ Microsoft –∏—Å–∫—É—Å—Ç–≤–∞ —É—á–∏–Ω–∏–º–æ —ò–æ—à –∫–æ—Ä–∏—Å–Ω–∏—ò–∏–º –∑–∞ –≤–∞—Å–•–∞—ò–¥–µ –¥–∞ –≤–µ–± —Ä–∞–¥–∏ –∑–∞ –≤–∞—Å–ü–æ–±–æ—ô—à–∞—ò—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—ò—É –æ–≥–ª–∞—à–∞–≤–